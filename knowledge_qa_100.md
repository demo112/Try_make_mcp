# 知识库待澄清问题集 (Generated)

生成时间: 2025-12-11 19:51:09
---

## 问题 1

**Q**: RAG策略中的Naive RAG、Advanced RAG和Modular RAG的核心区别及适用场景是什么？

**A**: Naive RAG采用"检索-生成"单一流程，适用于简单问答场景但缺乏动态调整能力；Advanced RAG通过预检索优化（如查询重写）和后检索优化（如交叉注意力机制）提升效果，适合复杂语义理解任务；Modular RAG引入可插拔模块化架构（如动态路由选择），能根据任务需求组合不同检索器和生成器，适用于多模态、多步骤推理场景。三者的核心差异在于系统架构复杂度和对上下文动态适应能力。

---

## 问题 2

**Q**: 在RAG策略中，如何通过向量数据库优化提升检索质量？

**A**: 向量数据库优化包含三个关键步骤：1）选择适合的索引类型（如HNSW或IVF-PQ），平衡检索速度与精度；2）优化分块策略（如调整chunk大小至512-1024 tokens并设置重叠区域），确保语义完整性和上下文关联；3）采用混合检索模式（向量+关键词），通过BM25等算法补充稀疏特征匹配。这些优化基于向量空间相似度计算原理，能有效解决语义鸿沟问题。

---

## 问题 3

**Q**: RAG策略中检索器与排序器的协同工作机制是怎样的？

**A**: 检索器（如FAISS）负责从知识库中快速筛选Top-K候选文档（通常5-10个），基于稠密向量相似度进行粗筛；排序器（如BERT交叉编码器）对候选文档进行深度语义分析，计算查询与文档的交互特征并重新排序。这种两阶段机制结合了召回效率与精排准确性，通过分离计算密集型任务，在保持实时性的同时将检索准确率提升30%以上。

---

## 问题 4

**Q**: 在多模块项目中如何解决依赖版本冲突问题？

**A**: 依赖管理工具通过版本收敛策略解决多模块版本冲突。Maven使用`<dependencyManagement>`统一声明版本号，Gradle通过`resolutionStrategy`强制指定版本。具体步骤包括：1. 分析依赖树定位冲突层级；2. 在父POM或根build.gradle中定义版本约束；3. 使用`exclusion`标签排除特定传递性依赖；4. 通过`mvn dependency:tree`或`gradle dependencies`验证收敛效果。该方法基于语义化版本控制原则和最近版本优先的解析机制。

---

## 问题 5

**Q**: 如何有效管理传递性依赖带来的复杂性？

**A**: 管理传递性依赖需遵循三步法：1. 显式声明关键依赖版本（如Spring Boot的BOM管理），避免隐式继承；2. 使用`mvn dependency:analyze`或`gradle dependencyInsight`分析依赖树；3. 通过`optional`标签（Maven）或`transitive=false`（Gradle）控制传递性。知识库强调应定期执行`npm ls`或`pipdeptree`检查嵌套依赖，并采用OWASP Dependency-Check进行安全扫描。该策略可降低"依赖地狱"风险并提升构建可预测性。

---

## 问题 6

**Q**: 依赖锁定机制（如package-lock.json）的工作原理是什么？

**A**: 依赖锁定文件通过记录完整解析树实现可重复构建。其原理包含：1. 在首次安装时生成精确版本哈希值；2. 存储每个依赖的全路径解析记录；3. 在后续安装时强制复用锁定版本。操作流程为：执行`npm install --package-lock-only`生成锁定文件，通过`npm ci`进行严格安装。该机制基于确定性解析算法，确保不同环境获得相同依赖树结构，符合DevOps的基础设施即代码理念。

---

